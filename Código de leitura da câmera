import torch
import torch.nn as nn
from torchvision import transforms, models
import cv2
from PIL import Image
import numpy as np
import requests
import time
import serial # Importa칞칚o para comunica칞칚o serial
import pyttsx3 # 游 IMPORTA칂츾O PARA S칈NTESE DE VOZ
import threading # 游 IMPORTA칂츾O PARA VOZ N츾O-BLOQUEANTE (Solu칞칚o do ex_Voz_repetida)

# ==============================================================================
# 0. FUN칂츾O DE VOZ N츾O-BLOQUEANTE (USANDO THREADING)
# ==============================================================================
def speak_non_blocking(texto):
    """
    Inicializa o motor de voz em um thread separado. Isso garante que a chamada
    runAndWait() n칚o bloqueie o loop principal de captura e processamento do v칤deo.
    """
    def _speak():
        # A inicializa칞칚o DENTRO do thread evita problemas de concorr칡ncia.
        engine = pyttsx3.init()
        engine.setProperty('rate', 150) # Velocidade da fala
        
        # Tenta definir uma voz espec칤fica (opcional, pode variar por sistema)
        try:
            voices = engine.getProperty('voices')
            if voices:
                engine.setProperty('voice', voices[0].id) 
        except Exception:
            pass # Continua mesmo que falhe ao definir a voz
            
        print(f"[FALA] Disparando: {texto}")
        engine.say(texto)
        engine.runAndWait() # Bloqueia APENAS este thread secund치rio
        
    # Inicia o thread. 'daemon=True' garante que ele se encerra com o programa principal.
    threading.Thread(target=_speak, daemon=True).start()


# ==============================================================================
# 1. CONFIGURA칂칏ES DO PROJETO, IOT E ARDUINO (AJUSTE AQUI)
# ==============================================================================
MODEL_PATH = 'best_luva_classifier.pth' 
IMAGE_SIZE = 224 
NUM_CLASSES = 2
CLASSES = ['com_defeito', 'sem_defeito']
device = torch.device("cpu")
CAMERA_INDEX = 1 

# CONFIGURA칂칏ES ARDUINO 
SERIAL_PORT = 'COM4' # 丘멆잺 AJUSTE PARA A PORTA CORRETA.
SERIAL_BAUD_RATE = 9600

# CONFIGURA칂칏ES THINGER.IO 
THINGER_IO_URL = f"https://backend.thinger.io/v3/users/Ingrid/devices/Inspecao_qualidade_luva/callback/data"  
THINGER_IO_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkZXYiOiJJbnNwZWNhb19xdWFsaWRhZGVfbHV2YSIsImlhdCI6MTc2MTMzODQyMiwianRpIjoiNjhmYmU0MzYzMGExZDg0YjZiMDRiOTM0Iiwic3ZyIjoidXMtZWFzdC5hd3MudGhpbmdlci5pbyIsInVzciI6IkluZ3JpZCJ9.t5ojYCX5k0m0A5csBHMRbcbaNtwyKbMAQ8Eg-csxVTk"
SEND_INTERVAL = 60 
# ==============================================================================


# ==============================================================================
# 2. FUN칂츾O DE ENVIO DE DADOS SERIAL E IOT
# ==============================================================================
def send_serial_command(ser_connection, command):
    """Envia um comando Serial ('V', 'R' ou 'N') para o Arduino."""
    if not isinstance(ser_connection, serial.Serial):
        return 
    try:
        ser_connection.write(command.encode()) 
    except serial.SerialException as e:
        print(f"[ERRO SERIAL] Falha ao enviar comando para Arduino: {e}")
    except Exception as e:
          print(f"[ERRO SERIAL DESCONHECIDO] {e}")


def send_data_to_thingerio(decision, approved_count, rejected_count):
    """Envia o status atual da inspe칞칚o e as contagens para o Thinger.io."""
    
    payload = {
        "status_luva": decision,
        "aprovadas": approved_count,
        "rejeitadas": rejected_count
    }
    
    headers = {
        'Authorization': f'Bearer {THINGER_IO_TOKEN}',
        'Content-Type': 'application/json'
    }
    
    try:
        response = requests.post(THINGER_IO_URL, json=payload, headers=headers)
        response.raise_for_status() 
        print(f"[SUCESSO THINGER.IO] Dados enviados. Status: {response.status_code}")
        
    except requests.exceptions.RequestException as e:
        print(f"[ERRO THINGER.IO] Falha ao enviar dados: {e}")


# ==============================================================================
# 3. PR칄-PROCESSAMENTO e 4. CLASSIFICAR FRAME
# ==============================================================================
val_test_transforms = transforms.Compose([
    transforms.Resize(IMAGE_SIZE),
    transforms.CenterCrop(IMAGE_SIZE),
    transforms.ToTensor(),  
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

def classify_frame(model, frame, transform):
    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    pil_image = Image.fromarray(img_rgb)
    input_tensor = transform(pil_image)
    input_batch = input_tensor.unsqueeze(0)

    with torch.no_grad():
        output = model(input_batch.to(device))

    probabilities = torch.nn.functional.softmax(output[0], dim=0)
    confidence, predicted_index = torch.max(probabilities, 0)

    pred_class = CLASSES[predicted_index.item()]
    confidence_val = confidence.item()

    if pred_class == 'sem_defeito' and confidence_val >= 0.6:
        decision = "APROVADA"
        color = (0, 255, 0) # Verde
    elif pred_class == 'com_defeito' and confidence_val >= 0.6:
        decision = "REJEITADA"
        color = (0, 0, 255) # Vermelho
    else:
        decision = "INDEFINIDO"
        color = (255, 255, 0) # Amarelo

    return pred_class, confidence_val, decision, color


# ==============================================================================
# 5. FUN칂츾O PRINCIPAL: LOOP DE INSPE칂츾O E CONTROLE
# ==============================================================================
def main():
    # 1. Carregar o modelo
    model_ft = models.resnet18(weights=models.ResNet18_Weights.IMAGENET1K_V1)
    num_ftrs = model_ft.fc.in_features
    model_ft.fc = nn.Linear(num_ftrs, NUM_CLASSES)
    model_ft.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model_ft.to(device)
    model_ft.eval()

    # 2. Iniciar C칙mera
    cap = cv2.VideoCapture(CAMERA_INDEX)
    if not cap.isOpened():
        print(f"ERRO: N칚o foi poss칤vel abrir a c칙mera no 칤ndice {CAMERA_INDEX}.")
        return

    # -------------------------------------------------------------
    # INICIALIZA칂츾O DA CONEX츾O SERIAL
    # -------------------------------------------------------------
    arduino_serial = None
    try:
        arduino_serial = serial.Serial(SERIAL_PORT, SERIAL_BAUD_RATE, timeout=1)
        time.sleep(2) 
        print(f"[SERIAL] Conex칚o Arduino estabelecida em {SERIAL_PORT}.")
    except serial.SerialException as e:
        print(f"[ERRO FATAL SERIAL] N칚o foi poss칤vel conectar ao Arduino em {SERIAL_PORT}: {e}")
        arduino_serial = None 
        print("Prosseguindo com inspe칞칚o, mas sem controle de LED.")
    # -------------------------------------------------------------
    
    # 游 O motor de voz ser치 inicializado de forma n칚o-bloqueante na fun칞칚o 'speak_non_blocking'
    
    # Inicializa칞칚o dos Contadores
    approved_count = 0
    rejected_count = 0
    last_send_time = time.time()
    last_decision = "INICIANDO" 

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        pred_class, confidence, decision, color = classify_frame(model_ft, frame, val_test_transforms)
        
        # L칩gica de controle de LED, Contagem e VOZ
        # 游 S칩 executa se a decis칚o MUDOU (ou se est치 saindo de INDEFINIDO)
        if decision != last_decision:
            
            speech_text = ""
            command = 'N' # Comando padr칚o neutro
            
            # 1. Controle Serial e Defini칞칚o da Fala
            if decision == "APROVADA":
                command = 'V' # 'V' para Verde
                speech_text = "Luva APROVADA!"
            elif decision == "REJEITADA":
                command = 'R' # 'R' para Vermelho
                speech_text = "Luva REJEITADA!"
            
            
            # 2. Executa o Comando Serial (V, R ou N)
            if arduino_serial:
                send_serial_command(arduino_serial, command)

            # 游 3. S칈NTESE DE VOZ: CHAMA A FUN칂츾O N츾O-BLOQUEANTE
            if speech_text:
                speak_non_blocking(speech_text) 
                
            # 4. L칩gica de Incremento (Contadores)
            if decision == "APROVADA":
                approved_count += 1
            elif decision == "REJEITADA":
                rejected_count += 1
            
            last_decision = decision # Atualiza a 칰ltima decis칚o
        
        
        # L칍GICA DE ENVIO IOT A CADA 60 SEGUNDOS
        current_time = time.time()
        if current_time - last_send_time >= SEND_INTERVAL:
            # Envia a 칰ltima decis칚o clara e as contagens
            send_data_to_thingerio(last_decision, approved_count, rejected_count)
            last_send_time = current_time 

        # Exibi칞칚o no Frame
        text_prediction = f"Classe: {pred_class.upper()} (Conf: {confidence:.2f})"
        text_decision = f"DECISAO: {decision}"
        
        cv2.putText(frame, text_prediction, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2, cv2.LINE_AA)
        cv2.putText(frame, text_decision, (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2, cv2.LINE_AA)

        time_remaining = SEND_INTERVAL - int(current_time - last_send_time)
        text_counts = f"Aprovadas: {approved_count} | Rejeitadas: {rejected_count} | IOT em: {time_remaining}s"
        cv2.putText(frame, text_counts, (10, 110), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2, cv2.LINE_AA)
        
        cv2.imshow('Inspe칞칚o em Tempo Real', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # FECHAMENTO DA CONEX츾O SERIAL
    if arduino_serial and arduino_serial.is_open:
        send_serial_command(arduino_serial, 'N') 
        arduino_serial.close()
        print("[SERIAL] Conex칚o Arduino encerrada.")

    cap.release()
    cv2.destroyAllWindows()
    print("\nFeed da c칙mera encerrado.")

if __name__ == '__main__':
    try:
        import serial
    except ImportError:
        print("M칩dulo 'pyserial' n칚o encontrado. Instale com: pip install pyserial")
        exit()
        
    main()
