import torch
import torch.nn as nn
from torchvision import transforms, models
import cv2
from PIL import Image
import numpy as np
import requests
import time
import serial 
import pyttsx3 
import threading 

# ==============================================================================
# 0. FUN√á√ÉO DE VOZ N√ÉO-BLOQUEANTE (COM VOLUME M√ÅXIMO)
# ==============================================================================
def speak_non_blocking(texto):
    """
    Inicializa o motor de voz em um thread separado, com o volume no m√°ximo (1.0).
    """
    def _speak():
        engine = pyttsx3.init()
        engine.setProperty('rate', 150) # Velocidade da fala
        engine.setProperty('volume', 1.0) # üåü AUMENTA O VOLUME PARA O M√ÅXIMO
        
        try:
            voices = engine.getProperty('voices')
            if voices:
                engine.setProperty('voice', voices[0].id) 
        except Exception:
            pass
            
        print(f"[FALA] Disparando: {texto}")
        engine.say(texto)
        engine.runAndWait() 
        
    threading.Thread(target=_speak, daemon=True).start()


# ==============================================================================
# 1. CONFIGURA√á√ïES DO PROJETO, IOT E ARDUINO (AJUSTE AQUI)
# ==============================================================================
MODEL_PATH = 'best_luva_classifier.pth' 
IMAGE_SIZE = 224 
NUM_CLASSES = 2
CLASSES = ['com_defeito', 'sem_defeito']
device = torch.device("cpu")
CAMERA_INDEX = 1 

# CONFIGURA√á√ïES ARDUINO 
SERIAL_PORT = 'COM4' # ‚ö†Ô∏è AJUSTE PARA A PORTA CORRETA.
SERIAL_BAUD_RATE = 9600

# CONFIGURA√á√ïES THINGER.IO 
THINGER_IO_URL = f"https://backend.thinger.io/v3/users/Ingrid/devices/Inspecao_qualidade_luva/callback/data"  
THINGER_IO_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkZXYiOiJJbnNwZWNhb19xdWFsaWRhZGVfbHV2YSIsImlhdCI6MTc2MTMzODQyMiwianRpIjoiNjhmYmU0MzYzMGExZDg0YjZiMDRiOTM0Iiwic3ZyIjoidXMtZWFzdC5hd3MudGhpbmdlci5pbyIsInVzciI6IkluZ3JpZCJ9.t5ojYCX5k0m0A5csBHMRbcbaNtwyKbMAQ8Eg-csxVTk"
SEND_INTERVAL = 60 
# ==============================================================================


# ==============================================================================
# 2. FUN√á√ÉO DE ENVIO DE DADOS SERIAL E IOT
# ==============================================================================
def send_serial_command(ser_connection, command):
    """Envia um comando Serial ('V', 'R' ou 'N') para o Arduino."""
    if not isinstance(ser_connection, serial.Serial):
        return 
    try:
        ser_connection.write(command.encode()) 
    except serial.SerialException as e:
        print(f"[ERRO SERIAL] Falha ao enviar comando para Arduino: {e}")
    except Exception as e:
          print(f"[ERRO SERIAL DESCONHECIDO] {e}")


def send_data_to_thingerio(decision, approved_count, rejected_count):
    """Envia o status atual da inspe√ß√£o e as contagens para o Thinger.io."""
    
    payload = {
        "status_luva": decision,
        "aprovadas": approved_count,
        "rejeitadas": rejected_count
    }
    
    headers = {
        'Authorization': f'Bearer {THINGER_IO_TOKEN}',
        'Content-Type': 'application/json'
    }
    
    try:
        response = requests.post(THINGER_IO_URL, json=payload, headers=headers)
        response.raise_for_status() 
        print(f"[SUCESSO THINGER.IO] Dados enviados. Status: {response.status_code}")
        
    except requests.exceptions.RequestException as e:
        print(f"[ERRO THINGER.IO] Falha ao enviar dados: {e}")


# ==============================================================================
# 3. PR√â-PROCESSAMENTO e 4. CLASSIFICAR FRAME
# ==============================================================================
val_test_transforms = transforms.Compose([
    transforms.Resize(IMAGE_SIZE),
    transforms.CenterCrop(IMAGE_SIZE),
    transforms.ToTensor(),  
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

def classify_frame(model, frame, transform):
    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    pil_image = Image.fromarray(img_rgb)
    input_tensor = transform(pil_image)
    input_batch = input_tensor.unsqueeze(0)

    with torch.no_grad():
        output = model(input_batch.to(device))

    probabilities = torch.nn.functional.softmax(output[0], dim=0)
    confidence, predicted_index = torch.max(probabilities, 0)

    pred_class = CLASSES[predicted_index.item()]
    confidence_val = confidence.item()

    if pred_class == 'sem_defeito' and confidence_val >= 0.6:
        decision = "APROVADA"
        color = (0, 255, 0) # Verde
    elif pred_class == 'com_defeito' and confidence_val >= 0.6:
        decision = "REJEITADA"
        color = (0, 0, 255) # Vermelho
    else:
        decision = "INDEFINIDO"
        color = (255, 255, 0) # Amarelo

    return pred_class, confidence_val, decision, color


# ==============================================================================
# 5. FUN√á√ÉO PRINCIPAL: LOOP DE INSPE√á√ÉO E CONTROLE
# ==============================================================================
def main():
    # 1. Carregar o modelo
    model_ft = models.resnet18(weights=models.ResNet18_Weights.IMAGENET1K_V1)
    num_ftrs = model_ft.fc.in_features
    model_ft.fc = nn.Linear(num_ftrs, NUM_CLASSES)
    model_ft.load_state_dict(torch.load(MODEL_PATH, map_location=device))
    model_ft.to(device)
    model_ft.eval()

    # 2. Iniciar C√¢mera
    cap = cv2.VideoCapture(CAMERA_INDEX)
    if not cap.isOpened():
        print(f"ERRO: N√£o foi poss√≠vel abrir a c√¢mera no √≠ndice {CAMERA_INDEX}.")
        return

    # -------------------------------------------------------------
    # INICIALIZA√á√ÉO DA CONEX√ÉO SERIAL
    # -------------------------------------------------------------
    arduino_serial = None
    try:
        arduino_serial = serial.Serial(SERIAL_PORT, SERIAL_BAUD_RATE, timeout=1)
        time.sleep(2) 
        print(f"[SERIAL] Conex√£o Arduino estabelecida em {SERIAL_PORT}.")
    except serial.SerialException as e:
        print(f"[ERRO FATAL SERIAL] N√£o foi poss√≠vel conectar ao Arduino em {SERIAL_PORT}: {e}")
        arduino_serial = None 
        print("Prosseguindo com inspe√ß√£o, mas sem controle de LED.")
    # -------------------------------------------------------------
    
    # Inicializa√ß√£o dos Contadores
    approved_count = 0
    rejected_count = 0
    last_send_time = time.time()
    last_decision = "INICIANDO" 

    while True:
        # ----------------- MEDI√á√ÉO DE INFER√äNCIA --------------------
        start_time_loop = time.time() # üåü Come√ßa a contagem
        # ------------------------------------------------------------
        
        ret, frame = cap.read()
        if not ret:
            break

        # Captura do frame, pr√©-processamento e infer√™ncia
        pred_class, confidence, decision, color = classify_frame(model_ft, frame, val_test_transforms)
        
        # ------------------------------------------------------------
        end_time_loop = time.time() # üåü Termina a contagem
        
        # Calcula o tempo de infer√™ncia em milissegundos
        inference_time_ms = (end_time_loop - start_time_loop) * 1000
        # Calcula o FPS (Frames per Second)
        # O FPS √© mais baixo do que a taxa de frames da c√¢mera, pois inclui o tempo de infer√™ncia.
        fps = 1 / (end_time_loop - start_time_loop) 
        # ------------------------------------------------------------
        
        # L√≥gica de controle de LED, Contagem e VOZ
        if decision != last_decision:
            
            speech_text = ""
            command = 'N' # Comando padr√£o neutro
            
            # 1. Controle Serial e Defini√ß√£o da Fala
            if decision == "APROVADA":
                command = 'V' # 'V' para Verde
                speech_text = "Luva APROVADA!"
            elif decision == "REJEITADA":
                command = 'R' # 'R' para Vermelho
                speech_text = "Luva REJEITADA!"
            
            # 2. Executa o Comando Serial (V, R ou N)
            if arduino_serial:
                send_serial_command(arduino_serial, command)

            # 3. S√çNTESE DE VOZ: CHAMA A FUN√á√ÉO N√ÉO-BLOQUEANTE
            if speech_text:
                speak_non_blocking(speech_text) 
                
            # 4. L√≥gica de Incremento (Contadores)
            if decision == "APROVADA":
                approved_count += 1
            elif decision == "REJEITADA":
                rejected_count += 1
            
            last_decision = decision # Atualiza a √∫ltima decis√£o
        
        
        # L√ìGICA DE ENVIO IOT A CADA 60 SEGUNDOS
        current_time = time.time()
        if current_time - last_send_time >= SEND_INTERVAL:
            # Envia a √∫ltima decis√£o clara e as contagens
            send_data_to_thingerio(last_decision, approved_count, rejected_count)
            last_send_time = current_time 

        # Exibi√ß√£o no Frame
        text_prediction = f"Classe: {pred_class.upper()} (Conf: {confidence:.2f})"
        text_decision = f"DECISAO: {decision}"
        
        cv2.putText(frame, text_prediction, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2, cv2.LINE_AA)
        cv2.putText(frame, text_decision, (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2, cv2.LINE_AA)

        time_remaining = SEND_INTERVAL - int(current_time - last_send_time)
        text_counts = f"Aprovadas: {approved_count} | Rejeitadas: {rejected_count} | IOT em: {time_remaining}s"
        cv2.putText(frame, text_counts, (10, 110), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2, cv2.LINE_AA)
        
        # üåü NOVO: EXIBI√á√ÉO DO TEMPO DE INFER√äNCIA E FPS
        text_timing = f"Tempo Infer: {inference_time_ms:.2f} ms | FPS: {fps:.1f}"
        cv2.putText(frame, text_timing, (10, 150), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 165, 0), 2, cv2.LINE_AA) # Laranja
        
        cv2.imshow('Inspe√ß√£o em Tempo Real', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # FECHAMENTO DA CONEX√ÉO SERIAL
    if arduino_serial and arduino_serial.is_open:
        send_serial_command(arduino_serial, 'N') 
        arduino_serial.close()
        print("[SERIAL] Conex√£o Arduino encerrada.")

    cap.release()
    cv2.destroyAllWindows()
    print("\nFeed da c√¢mera encerrado.")

if __name__ == '__main__':
    try:
        import serial
    except ImportError:
        print("M√≥dulo 'pyserial' n√£o encontrado. Instale com: pip install pyserial")
        exit()
        
    main()
